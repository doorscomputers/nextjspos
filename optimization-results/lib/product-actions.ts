/**
 * Product Actions Utility
 * Business logic for product operations (delete, duplicate, activate)
 */

import { prisma } from '@/lib/prisma'
import { ProductDeleteValidation, DuplicateProductResult } from '@/types/product'

/**
 * Validate if a product can be deleted
 * Based on Laravel logic - checks for purchases, sold opening stock, and adjustments
 */
export async function validateProductDelete(
  productId: number,
  businessId: number
): Promise<ProductDeleteValidation> {
  const reasons: string[] = []
  let canDelete = true

  // Check if product has any purchases
  const purchaseCount = await prisma.stockTransaction.count({
    where: {
      productId,
      businessId,
      type: 'purchase'
    }
  })

  if (purchaseCount > 0) {
    canDelete = false
    reasons.push('This product has purchase history and cannot be deleted')
  }

  // Check if opening stock has been sold
  const openingStockSold = await prisma.stockTransaction.count({
    where: {
      productId,
      businessId,
      type: 'opening_stock',
      // If balance quantity is less than original quantity, it means some was sold
      NOT: {
        balanceQty: {
          equals: prisma.stockTransaction.fields.quantity
        }
      }
    }
  })

  if (openingStockSold > 0) {
    canDelete = false
    reasons.push('Opening stock for this product has been sold and cannot be deleted')
  }

  // Check if product has stock adjustments
  const adjustmentCount = await prisma.stockTransaction.count({
    where: {
      productId,
      businessId,
      type: 'adjustment'
    }
  })

  if (adjustmentCount > 0) {
    canDelete = false
    reasons.push('This product has stock adjustments and cannot be deleted')
  }

  return {
    canDelete,
    reasons,
    hasPurchases: purchaseCount > 0,
    hasOpeningStockSold: openingStockSold > 0,
    hasStockAdjustments: adjustmentCount > 0
  }
}

/**
 * Delete a product with validation
 * Performs soft delete only if validation passes
 */
export async function deleteProduct(
  productId: number,
  businessId: number
): Promise<{ success: boolean; message: string; errors?: string[] }> {
  // Verify product exists and belongs to business
  const product = await prisma.product.findFirst({
    where: {
      id: productId,
      businessId,
      deletedAt: null
    }
  })

  if (!product) {
    return {
      success: false,
      message: 'Product not found'
    }
  }

  // Validate if product can be deleted
  const validation = await validateProductDelete(productId, businessId)

  if (!validation.canDelete) {
    return {
      success: false,
      message: 'Product cannot be deleted',
      errors: validation.reasons
    }
  }

  // Perform soft delete
  await prisma.product.update({
    where: { id: productId },
    data: { deletedAt: new Date() }
  })

  return {
    success: { select: { id: true, name: true } },
    message: 'Product deleted successfully'
  }
}

/**
 * Duplicate a product with all its variations
 * Creates a new product with same details but new SKU
 */
export async function duplicateProduct(
  productId: number,
  businessId: number,
  userId: number,
  nameSuffix: string = ' (Copy)'
): Promise<DuplicateProductResult> {
  // Get original product with all relations
  const originalProduct = await prisma.product.findFirst({
    where: {
      id: productId,
      businessId,
      deletedAt: null
    },
    select: {
      variations: {
        where: { deletedAt: null }
      },
      comboProducts: { select: { id: true, name: true } }
    }
  })

  if (!originalProduct) {
    throw new Error('Product not found')
  }

  // Get business settings for SKU generation
  const business = await prisma.business.findUnique({
    where: { id: businessId },
    select: { skuPrefix: { select: { id: true, name: true } }, skuFormat: { select: { id: true, name: true } } }
  })

  if (!business) {
    throw new Error('Business not found')
  }

  // Use transaction to ensure data integrity
  const newProduct = await prisma.$transaction(async (tx) => {
    // Create new product (SKU will be auto-generated by trigger or application logic)
    const created = await tx.product.create({
      data: {
        businessId,
        name: originalProduct.name + nameSuffix,
        type: originalProduct.type,
        categoryId: originalProduct.categoryId,
        brandId: originalProduct.brandId,
        unitId: originalProduct.unitId,
        taxId: originalProduct.taxId,
        taxType: originalProduct.taxType,
        sku: '', // Will be generated
        barcodeType: originalProduct.barcodeType,
        description: originalProduct.description,
        productDescription: originalProduct.productDescription,
        image: originalProduct.image,
        brochure: originalProduct.brochure,
        enableStock: originalProduct.enableStock,
        alertQuantity: originalProduct.alertQuantity,
        purchasePrice: originalProduct.purchasePrice,
        sellingPrice: originalProduct.sellingPrice,
        weight: originalProduct.weight,
        preparationTime: originalProduct.preparationTime,
        enableProductInfo: originalProduct.enableProductInfo,
        notForSelling: originalProduct.notForSelling
      }
    })

    // Generate SKU based on new product ID
    const prefix = business.skuPrefix || 'PROD'
    const format = business.skuFormat || 'hyphen'
    const newSku = format === 'hyphen'
      ? `${prefix}-${created.id.toString().padStart(3, '0')}`
      : `${prefix}${created.id.toString().padStart(3, '0')}`

    // Update with generated SKU
    const updatedProduct = await tx.product.update({
      where: { id: created.id },
      data: { sku: newSku }
    })

    // Duplicate variations if product type is variable
    if (originalProduct.type === 'variable' && originalProduct.variations.length > 0) {
      let counter = 1
      for (const variation of originalProduct.variations) {
        const variationSku = `${newSku}-${counter.toString().padStart(2, '0')}`

        await tx.productVariation.create({
          data: {
            productId: created.id,
            name: variation.name,
            sku: variationSku,
            purchasePrice: variation.purchasePrice,
            sellingPrice: variation.sellingPrice,
            isDefault: variation.isDefault,
            subSku: variation.subSku,
            unitId: variation.unitId
          }
        })

        counter++
      }
    }

    // Duplicate combo items if product type is combo
    if (originalProduct.type === 'combo' && originalProduct.comboProducts.length > 0) {
      for (const comboItem of originalProduct.comboProducts) {
        await tx.comboProduct.create({
          data: {
            parentProductId: created.id,
            childProductId: comboItem.childProductId,
            quantity: comboItem.quantity
          }
        })
      }
    }

    return updatedProduct
  })

  return {
    productId: newProduct.id,
    message: 'Product duplicated successfully'
  }
}

/**
 * Reactivate a soft-deleted product
 */
export async function activateProduct(
  productId: number,
  businessId: number
): Promise<{ success: boolean; message: string }> {
  const product = await prisma.product.findFirst({
    where: {
      id: productId,
      businessId
    }
  })

  if (!product) {
    return {
      success: false,
      message: 'Product not found'
    }
  }

  if (!product.deletedAt) {
    return {
      success: false,
      message: 'Product is already active'
    }
  }

  await prisma.product.update({
    where: { id: productId },
    data: { deletedAt: null }
  })

  return {
    success: { select: { id: true, name: true } },
    message: 'Product activated successfully'
  }
}

/**
 * Get product details with all relations
 * Used for viewing complete product information
 */
export async function getProductDetails(productId: number, businessId: number) {
  const product = await prisma.product.findFirst({
    where: {
      id: productId,
      businessId,
      deletedAt: null
    },
    select: {
      category: { select: { id: { select: { id: true, name: true } }, name: { select: { id: true, name: true } } } },
      brand: { select: { id: true, name: true } },
      unit: { select: { id: true, name: true } },
      tax: { select: { id: true, name: true } },
      variations: {
        where: { deletedAt: null },
        select: {
          unit: { select: { id: { select: { id: true, name: true } }, name: { select: { id: true, name: true } } } },
          variationLocationDetails: {
            select: {
              // Note: BusinessLocation relation would need to be added to schema
            }
          }
        },
        orderBy: {
          createdAt: 'asc'
        }
      },
      comboProducts: {
        select: {
          childProduct: {
            select: {
              unit: { select: { id: { select: { id: true, name: true } }, name: { select: { id: true, name: true } } } },
              variations: {
                where: { deletedAt: null },
                select: {
                  variationLocationDetails: { select: { id: { select: { id: true, name: true } }, name: { select: { id: true, name: true } } } }
                }
              }
            }
          }
        }
      }
    }
  })

  if (!product) {
    return null
  }

  // Calculate total stock across all locations
  let totalStock = 0
  const stockByLocation: { locationId: number; quantity: number }[] = []

  if (product.enableStock) {
    if (product.type === 'variable') {
      // Aggregate stock from all variations
      for (const variation of product.variations) {
        for (const detail of variation.variationLocationDetails) {
          totalStock += parseFloat(detail.qtyAvailable.toString())

          // Group by location
          const existingLocation = stockByLocation.find(
            loc => loc.locationId === detail.locationId
          )
          if (existingLocation) {
            existingLocation.quantity += parseFloat(detail.qtyAvailable.toString())
          } else {
            stockByLocation.push({
              locationId: detail.locationId,
              quantity: parseFloat(detail.qtyAvailable.toString())
            })
          }
        }
      }
    }
  }

  return {
    ...product,
    totalStock,
    stockByLocation
  }
}
