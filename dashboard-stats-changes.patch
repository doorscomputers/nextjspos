diff --git a/src/app/api/dashboard/stats/route.ts b/src/app/api/dashboard/stats/route.ts
index 324b5f2..944d04f 100644
--- a/src/app/api/dashboard/stats/route.ts
+++ b/src/app/api/dashboard/stats/route.ts
@@ -97,142 +97,137 @@ export async function GET(request: NextRequest) {
       dateFilter.lte = new Date(endDate)
     }
 
-    // Total Sales - only query if user has permission
-    const salesData = hasPermission(PERMISSIONS.SELL_VIEW) ? await prisma.sale.aggregate({
-      where: {
-        ...whereClause,
-        ...(Object.keys(dateFilter).length > 0 ? { saleDate: dateFilter } : {}),
-      },
-      _sum: {
-        totalAmount: true,
-        subtotal: true,
-      },
-      _count: true,
-    }) : { _sum: { totalAmount: null, subtotal: null }, _count: 0 }
-
-    // Total Purchases - sum of all purchase amounts
-    const purchaseData = await prisma.accountsPayable.aggregate({
-      where: {
-        businessId,
-        ...(locationId && locationId !== 'all' ? {
-          purchase: { locationId: parseInt(locationId) }
-        } : {}),
-        ...(Object.keys(dateFilter).length > 0 ? { invoiceDate: dateFilter } : {}),
-      },
-      _sum: {
-        totalAmount: true,
-      },
-      _count: true,
-    })
+    // ⚡ PARALLEL EXECUTION: Run all queries simultaneously for maximum speed
+    const [
+      salesData,
+      purchaseData,
+      customerReturnData,
+      supplierReturnData,
+      invoiceDue,
+      purchaseDue
+    ] = await Promise.all([
+      // Total Sales
+      hasPermission(PERMISSIONS.SELL_VIEW)
+        ? prisma.sale.aggregate({
+            where: {
+              ...whereClause,
+              ...(Object.keys(dateFilter).length > 0 ? { saleDate: dateFilter } : {}),
+            },
+            _sum: { totalAmount: true, subtotal: true },
+            _count: true,
+          })
+        : Promise.resolve({ _sum: { totalAmount: null, subtotal: null }, _count: 0 }),
+
+      // Total Purchases
+      prisma.accountsPayable.aggregate({
+        where: {
+          businessId,
+          ...(locationId && locationId !== 'all' ? {
+            purchase: { locationId: parseInt(locationId) }
+          } : {}),
+          ...(Object.keys(dateFilter).length > 0 ? { invoiceDate: dateFilter } : {}),
+        },
+        _sum: { totalAmount: true },
+        _count: true,
+      }),
+
+      // Customer Returns
+      hasPermission(PERMISSIONS.CUSTOMER_RETURN_VIEW)
+        ? prisma.customerReturn.aggregate({
+            where: {
+              businessId,
+              ...(Object.keys(dateFilter).length > 0 ? { returnDate: dateFilter } : {}),
+            },
+            _sum: { totalRefundAmount: true },
+            _count: true,
+          })
+        : Promise.resolve({ _sum: { totalRefundAmount: null }, _count: 0 }),
+
+      // Supplier Returns
+      prisma.supplierReturn.aggregate({
+        where: {
+          businessId,
+          ...(Object.keys(dateFilter).length > 0 ? { returnDate: dateFilter } : {}),
+        },
+        _sum: { totalAmount: true },
+        _count: true,
+      }),
+
+      // Invoice Due
+      hasPermission(PERMISSIONS.SELL_VIEW)
+        ? prisma.sale.aggregate({
+            where: {
+              ...whereClause,
+              status: { not: 'cancelled' },
+            },
+            _sum: { totalAmount: true },
+          })
+        : Promise.resolve({ _sum: { totalAmount: null } }),
+
+      // Purchase Due
+      prisma.accountsPayable.aggregate({
+        where: {
+          businessId,
+          ...(locationId && locationId !== 'all' ? {
+            purchase: { locationId: parseInt(locationId) }
+          } : {}),
+          paymentStatus: { in: ['unpaid', 'partial', 'overdue'] },
+        },
+        _sum: { balanceAmount: true },
+      })
+    ])
 
     // Total Expenses - TODO: Implement Expense model
-    const expenseData = { _sum: { amount: null } } // Placeholder until Expense model is created
-    // const expenseData = await prisma.expense.aggregate({
-    //   where: {
-    //     ...whereClause,
-    //     ...(Object.keys(dateFilter).length > 0 ? { expenseDate: dateFilter } : {}),
-    //   },
-    //   _sum: {
-    //     amount: true,
-    //   },
-    // })
-
-    // Customer Returns - only query if user has permission
-    const customerReturnData = hasPermission(PERMISSIONS.CUSTOMER_RETURN_VIEW) ? await prisma.customerReturn.aggregate({
-      where: {
-        businessId,
-        ...(Object.keys(dateFilter).length > 0 ? { returnDate: dateFilter } : {}),
-      },
-      _sum: {
-        totalRefundAmount: true,
-      },
-      _count: true,
-    }) : { _sum: { totalRefundAmount: null }, _count: 0 }
-
-    // Supplier Returns
-    const supplierReturnData = await prisma.supplierReturn.aggregate({
-      where: {
-        businessId,
-        ...(Object.keys(dateFilter).length > 0 ? { returnDate: dateFilter } : {}),
-      },
-      _sum: {
-        totalAmount: true,
-      },
-      _count: true,
-    })
-
-    // Invoice Due (Sales with unpaid amounts) - only query if user has permission
-    const invoiceDue = hasPermission(PERMISSIONS.SELL_VIEW) ? await prisma.sale.aggregate({
-      where: {
-        ...whereClause,
-        status: { not: 'cancelled' },
-      },
-      _sum: {
-        totalAmount: true,
-      },
-    }) : { _sum: { totalAmount: null } }
-
-    // Purchase Due (Outstanding balance from Accounts Payable)
-    const purchaseDue = await prisma.accountsPayable.aggregate({
-      where: {
-        businessId,
-        ...(locationId && locationId !== 'all' ? {
-          purchase: { locationId: parseInt(locationId) }
-        } : {}),
-        paymentStatus: { in: ['unpaid', 'partial', 'overdue'] },
-      },
-      _sum: {
-        balanceAmount: true,
-      },
-    })
+    const expenseData = { _sum: { amount: null } }
 
-    // Sales Last 30 Days - only query if user has permission
+    // ⚡ PARALLEL EXECUTION: Run chart queries simultaneously
     const thirtyDaysAgo = new Date()
     thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
-
-    const salesLast30Days = hasPermission(PERMISSIONS.SELL_VIEW) ? await prisma.sale.groupBy({
-      by: ['saleDate'],
-      where: {
-        ...whereClause,
-        saleDate: { gte: thirtyDaysAgo },
-      },
-      _sum: {
-        totalAmount: true,
-      },
-      orderBy: {
-        saleDate: 'asc',
-      },
-    }) : []
-
-    // Sales Current Financial Year - only query if user has permission
     const currentYear = new Date().getFullYear()
     const financialYearStart = new Date(currentYear, 0, 1)
 
-    const salesCurrentYear = hasPermission(PERMISSIONS.SELL_VIEW) ? await prisma.sale.groupBy({
-      by: ['saleDate'],
-      where: {
-        ...whereClause,
-        saleDate: { gte: financialYearStart },
-      },
-      _sum: {
-        totalAmount: true,
-      },
-      orderBy: {
-        saleDate: 'asc',
-      },
-    }) : []
-
-    // Product Stock Alert (products below alert quantity)
-    // Get ALL products with alert quantity set, then filter
+    const [salesLast30Days, salesCurrentYear] = await Promise.all([
+      // Sales Last 30 Days
+      hasPermission(PERMISSIONS.SELL_VIEW)
+        ? prisma.sale.groupBy({
+            by: ['saleDate'],
+            where: {
+              ...whereClause,
+              saleDate: { gte: thirtyDaysAgo },
+            },
+            _sum: { totalAmount: true },
+            orderBy: { saleDate: 'asc' },
+          })
+        : Promise.resolve([]),
+
+      // Sales Current Financial Year
+      hasPermission(PERMISSIONS.SELL_VIEW)
+        ? prisma.sale.groupBy({
+            by: ['saleDate'],
+            where: {
+              ...whereClause,
+              saleDate: { gte: financialYearStart },
+            },
+            _sum: { totalAmount: true },
+            orderBy: { saleDate: 'asc' },
+          })
+        : Promise.resolve([])
+    ])
+
+    // Product Stock Alert - Optimized with limit
+    // Only fetch products that might be low on stock
     const allProductsWithAlerts = await prisma.variationLocationDetails.findMany({
       where: {
         ...(locationId && locationId !== 'all' ? { locationId: parseInt(locationId) } : {}),
         product: {
           businessId,
           alertQuantity: { not: null },
+          isActive: true,
+          deletedAt: null,
         },
       },
-      include: {
+      select: {
+        qtyAvailable: true,
         product: {
           select: {
             id: true,
@@ -247,6 +242,7 @@ export async function GET(request: NextRequest) {
           },
         },
       },
+      take: 50, // Limit query size
     })
 
     // Filter to find products where current quantity is below or equal to alert quantity
@@ -256,10 +252,9 @@ export async function GET(request: NextRequest) {
           ? parseFloat(item.product.alertQuantity.toString())
           : 0
         const currentQty = parseFloat(item.qtyAvailable.toString())
-        // Alert when current stock is at or below the alert quantity
         return alertQty > 0 && currentQty <= alertQty
       })
-      .slice(0, 10) // Take top 10 after filtering
+      .slice(0, 10)
 
     // Pending Shipments (Stock Transfers in transit or pending)
     // Show transfers that are not yet completed, cancelled, or received
